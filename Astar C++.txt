
cpp

include <iostream>

include <vector>

include <queue>

include <cmath>

include <unordered_map>

include <algorithm>

using namespace std;

struct Node {
    int x, y;
    float g, h;
    Node* parent;

    Node(int x, int y, float g = 0, float h = 0, Node*  parent = nullptr )
        : x(x), y(y), g(g), h(h), parent( parent ) {}

    float f() const { return g + h; }

    bool operator>(const Node& other) const {
        return f() > other.f();
    }

    bool operator==(const Node& other) const {
        return x == other.x && y == other.y;
    }
};

struct Compare {
    bool operator()(Node a, Node b) {
        return a->f() > b->f();
    }
};

float heuristic(int x1, int y1, int x2, int y2) {
    // Euclidean distance
    return sqrt(pow(x1 - x2, 2) + pow(y1 - y2, 2));
}

vector<Node> getNeighbors(Node current, const vector<vector<int>>& grid) {
    vector<Node*> neighbors;
    int dx[] = { -1, 1, 0, 0 };
    int dy[] = { 0, 0, -1, 1 };

    for (int i = 0; i < 4; ++i) {
        int nx = current->x + dx[i];
        int ny = current->y + dy[i];

        if (nx >= 0 && ny >= 0 && nx < grid.size() && ny < grid[0].size() && grid[nx][ny] == 0) {
            neighbors.push_back(new Node(nx, ny));
        }
    }
    return neighbors;
}

vector<Node> aStar(const vector<vector<int>>& grid, Node start, Node* goal) {
    priority_queue<Node, vector<Node>, Compare> openSet;
    unorderedmap<int, unorderedmap<int, bool>> closedSet;

    start->h = heuristic(start->x, start->y, goal->x, goal->y);
    openSet.push(start);

    while (!openSet.empty()) {
        Node* current = openSet.top();
        openSet.pop();

        if (current == goal) {
            vector<Node*> path;
            while (current) {
                path.push_back(current);
                current = current->parent;
            }
            reverse(path.begin(), path.end());
            return path;
        }

        closedSet[current->x][current->y] = true;

        for (Node* neighbor : getNeighbors(current, grid)) {
            if (closedSet[neighbor->x][neighbor->y]) continue;

            float tentative_g = current->g + 1;
            neighbor->g = tentative_g;
            neighbor->h = heuristic(neighbor->x, neighbor->y, goal->x, goal->y);
            neighbor->parent = current;

            openSet.push(neighbor);
        }
    }

    return {}; // No path found
}

int main() {
    vector<vector<int>> grid = {
        {0, 0, 0, 0, 0},
        {1, 1, 0, 1, 0},
        {0, 0, 0, 1, 0},
        {0, 1, 1, 1, 0},
        {0, 0, 0, 0, 0}
    };

    Node* start = new Node(0, 0);
    Node* goal = new Node(4, 4);

    vector<Node*> path = aStar(grid, start, goal);

    if (!path.empty()) {
        cout << "Path found:\n";
        for (Node* node : path) {
            cout << "(" << node-> x << "," << node -> y << ") ";
        }
        cout << endl;
    } else {
        cout << "No path found.\n";
    }

    return 0;
}






